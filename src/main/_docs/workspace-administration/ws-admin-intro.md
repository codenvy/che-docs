---
tags: [ "eclipse" , "che" ]
title: Workspaces
excerpt: ""
layout: docs
permalink: /:categories/admin-intro/
---
{% include base.html %}

{{product_formal_name}}'s power comes from the unique Eclipse Che workspaces which are portable and shareable because they are composed of projects (source files) and environments (runtimes). 

# How Che Workspaces Work
## 1. You start with a production runtime
- A Docker image or a “recipe”, for example a Dockerfile / Composefile
- Runtimes can inherit from other kinds of “machines” such as SSH 
- Images are built, if necessary, and run with additional run + volume mount parameters

## 2. Che "dev modes” the runtime
- Agents ⇒ ZIP package of bash software to be installed + started in the runtime (sshd, intellisense, sync)
- Agents ⇒ Can be added during workspace boot, or after it has started triggered by a developer activity
- Agents ⇒ Added through either a volume mount or HTTP download from the Che server - depending upon config
- Terminal Agent ⇒ Special purpose agent to provide web-based terminal
- WS Agent ⇒ Special purpose agent that must exist in one container providing Che APIs for Che server & browser clients
- Debuggers ⇒ Processes with special ports to be exposed, which allow debugger clients to connect

## 3. Che activates the project in the workspace
- Clone ⇒ Users can clone repos from remote locations
- Mount ⇒ Source code is volume mounted to the local server host for long term storage
- rsync ⇒ Distributed workspaces with Codenvy rsync project code from long term storage to a workspace runtime during boot

## 4. IDE clients are informed of workpace URL and endpoint
- Sync ⇒ Users can use a che-sync docker container to unison sync workspace files to localhost

# Che Workspace Model
### 1..n Environments
- 1..1 Recipes ⇒ defined by a “stack”
- 1..n Machines ⇒ machines have “type”, such as Docker or SSH and an SPI
- State, such as “running”, “stopped”, “booting”
- Runtime - the instantiated machines
- Snapshot - saved machine state

### 0..n Agents
- Microservices added to ws runtimes, such as SSH, dev-machine, or intellisense

### 0..n Projects
- Each mapped to a single repository or directory, with a “type”
- Type ⇒ such as “javac”, “c#” to inject behaviors into the ws
- Modules ⇒ sub-projects that have directory-sensitive behaviors
- Templates ⇒ Sample projects which can be instantiated in a workspace

### 0..n Commands
- Processes for users to perform tasks, such as compiling code, with a “type”
- Type ⇒ such as “javac”, “c#” to inject behaviors into the ws
- Previews ⇒ URLs generated by commands which give access to workspace “servers”

### 0..n IDEs
- An embedded IDE package, delivered to end user configured for the ws
- Che web IDE is included by default

![machine.png]({{ base }}/assets/imgs/machine.png)

# Where To Go From Here  
Che provides a lot of flexibility to administrators and users. You can start by choosing from our stack library that is within the user dashboard.

Or, if you want to distribute your own workspace configuration, study how to add a [Runtime Stack](doc:stacks) or a [Project Sample](doc:templates).

In the [Stacks](doc:stacks) section, we also provide instructions for how to write custom Dockerfiles or Docker Compose files that will act as a workspace recipes.
